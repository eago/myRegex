现代的正则引擎会强迫进行驱动过程，所以同一位置不会发生两次长度为0的匹配

"(\\.|[^\\"])*" --匹配双引号内的字符， 允许任何转义字符（包括转义的引号）

判断正则引擎的方法 ：
"([^\\"]+|\\.)*"
不能匹配也能很快给出结果 -DFA
只有匹配时才能很快给出结果 -NFA
总是很慢 -POSIX NFA （因为总是要尝试所有的可能性， + 与 * 的作用域造成指数增长）

如果无法匹配， 传统型 NFA 必须进行的尝试与 POSIX NFA 一样多

多选结构的代价很高（回溯的主要原因），尽量使用字符组

应用程序所提供的三种处理正则表达式的方式 ：集成式， 程序式 和 面向对象式

消除循环 没看太懂？

消除循环的方法 ："opening normal* (special normal*)* closing"

顺序环视结构中可以使用任意正则表达式， 但是逆序环视中的自表达式只能匹配长度有限的文本（? 可以，*, + 不可以）

Unicode 属性， 通过\p{Lu}之类的缩写名字来引用。

通常情况下，$ 和 \Z 通常会匹配行终结符（通常是 LF 换行符，多行模式下除外）之前的位置

Java StringBuilder 不能保证多线程安全， StringBuffer 可以

Java Pattern.compile().split(string regex, string text);

所有的图像都必须有 size (width, height) 属性 （浏览器在显示图像之前必须读入整个文件，如果包含了宽度和高度的尺寸，文本和其他元素就可以立即正确摆放， 这样用户会感觉页面读取速度更快 ）